<!DOCTYPE html>
<html lang="en">
<head>
    <title>Compliance Report</title>
    <style>
        table {
            border-collapse: collapse;
            width: 100%;
        }
        th, td {
            border: 1px solid black;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
        }
    </style>
    <script>
        function searchTable() {
            let inputTitle, inputNumber, inputProfile, filterTitle, filterNumber, filterProfile, table, tr, td, i, txtValue;
            inputTitle = document.getElementById("titleSearch");
            inputNumber = document.getElementById("numberSearch");
            inputProfile = document.getElementById("profileSearch");
            filterTitle = inputTitle.value.toUpperCase();
            filterNumber = inputNumber.value.toUpperCase();
            filterProfile = inputProfile.value.toUpperCase();
            table = document.getElementById("complianceTable");
            tr = table.getElementsByTagName("tr");

            for (i = 1; i < tr.length; i++) {
                tr[i].style.display = "none";
                td = tr[i].getElementsByTagName("td");
                if (td) {
                    var title = td[0].textContent || td[0].innerText;
                    var number = td[1].textContent || td[1].innerText;
                    var profile = td[3].textContent || td[3].innerText;
                    if (title.toUpperCase().indexOf(filterTitle) > -1 &&
                        number.toUpperCase().indexOf(filterNumber) > -1 &&
                        profile.toUpperCase().indexOf(filterProfile) > -1) {
                        tr[i].style.display = "";
                    }
                }
            }
        }
    </script>
</head>
<body>
    <h2>Compliance Report</h2>
    <label for="titleSearch">Search by Title:</label>
    <input type="text" id="titleSearch" onkeyup="searchTable()">
    <label for="numberSearch">Search by Number:</label>
    <input type="text" id="numberSearch" onkeyup="searchTable()">
    <label for="profileSearch">Search by Profile:</label>
    <input type="text" id="profileSearch" onkeyup="searchTable()">
    <table id="complianceTable">
        <thead>
            <tr>
                <th>TITLE</th>
                <th>NUMBER</th>
                <th>COMMANDS</th>
                <th>PROFILE</th>
                <th>DESCRIPTION</th>
                <th>PASSED</th>
            </tr>
        </thead>
        <tbody>
            
            <tr>
                <td>Ensure mounting of cramfs filesystems is disabled</td>
                <td>1.1.1.1</td>
                <td>['modprobe -n -v cramfs | grep "^install"', 'lsmod | grep cramfs', 'grep -E "^blacklist\\s+cramfs" /etc/modprobe.d/*']</td>
                <td>['Level 1 - Server', 'Level 1 - Workstation']</td>
                <td>The cramfs filesystem type is a compressed read - only Linux filesystem embedded in small
    footprint systems.A cramfs image can be used  without having to first decompress it. This can be used to mount  the
    image.</td>
                <td>False</td>
            </tr>
            
            <tr>
                <td>Ensure mounting of squashfs filesystems is disabled</td>
                <td>1.1.1.2</td>
                <td>['modprobe -n -v squashfs | grep "^install"', 'lsmod | grep squashfs', 'grep -E "^blacklist\\s+squashfs" /etc/modprobe.d/*']</td>
                <td>['Level 2 - Server', 'Level 2 - Workstation']</td>
                <td>The squashfs filesystem type is a compressed read-only Linux filesystem embedded in small 
    footprint systems. A squashfs image can be used without having to first decompress it. 
    Removing support for unneeded filesystem types reduces the local attack surface of the system. 
    If this filesystem type is not needed, disable it.
    Impact: As Snap packages utilizes squashfs as a compressed filesystem, disabling squashfs will cause Snap packages to fail. 
    Snap application packages of software are self-contained and work across a range of Linux distributions. 
    This is unlike traditional Linux package management approaches, like APT or RPM, which require specifically adapted 
    packages per Linux distribution on an application update and delay therefore application deployment from developers 
    to their software's end-user. Snaps themselves have no dependency on any external store ("App store"), can be obtained 
    from any source and can be therefore used for upstream software deployment.</td>
                <td>False</td>
            </tr>
            
            <tr>
                <td>Ensure mounting of udf filesystems is disabled</td>
                <td>1.1.1.3</td>
                <td>['modprobe -n -v udf | grep "^install"', 'lsmod | grep udf', 'grep -E "^blacklist\\s*udf" /etc/modprobe.d/*']</td>
                <td>['Level 2 - Server', 'Level 2 - Workstation']</td>
                <td>The udf filesystem type is the universal disk format used to implement ISO/IEC 13346 and ECMA-167 specifications. 
    This is an open vendor filesystem type for data storage on a broad range of media. This filesystem type is necessary 
    to support writing DVDs and newer optical disc formats. 
    Removing support for unneeded filesystem types reduces the local attack surface of the system. 
    If this filesystem type is not needed, disable it. 
    Impact: Microsoft Azure requires the usage of udf. 
    udf should not be disabled on systems run on Microsoft Azure.</td>
                <td>False</td>
            </tr>
            
            <tr>
                <td>Ensure /tmp is a separate partition</td>
                <td>1.1.2.1</td>
                <td>['findmnt --kernel /tmp', 'systemctl is-enabled tmp.mount']</td>
                <td>['Level 1 - Server', 'Level 1 - Workstation']</td>
                <td>The /tmp directory is a world-writable directory used for temporary storage by all users and some applications. 
    Making /tmp its own file system allows an administrator to set additional mount options such as the noexec option on the mount, 
    making /tmp useless for an attacker to install executable code. It would also prevent an attacker from establishing a hard link to 
    a system setuid program and wait for it to be updated. Once the program was updated, the hard link would be broken and the attacker 
    would have his own copy of the program. If the program happened to have a security vulnerability, the attacker could continue to exploit 
    the known flaw. This can be accomplished by either mounting tmpfs to /tmp, or creating a separate partition for /tmp.</td>
                <td>False</td>
            </tr>
            
            <tr>
                <td>Ensure nodev option set on /tmp partition</td>
                <td>1.1.2.2</td>
                <td>['findmnt --kernel /tmp | grep nodev']</td>
                <td>['Level 1 - Server', 'Level 1 - Workstation']</td>
                <td>The nodev mount option specifies that the filesystem cannot contain special devices.
    Since the /tmp filesystem is not intended to support devices, set this option to ensure that users cannot create 
    a block or character special devices in /tmp.</td>
                <td>False</td>
            </tr>
            
        </tbody>
    </table>
</body>
</html>